<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于Avalon_MM接口的SDRAM读写</title>
      <link href="/2023/05/23/%E5%9F%BA%E4%BA%8EAvalon_MM%E6%8E%A5%E5%8F%A3%E7%9A%84SDRAM%E8%AF%BB%E5%86%99/"/>
      <url>/2023/05/23/%E5%9F%BA%E4%BA%8EAvalon_MM%E6%8E%A5%E5%8F%A3%E7%9A%84SDRAM%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Avalon-MM接口的SDRAM读写"><a href="#基于Avalon-MM接口的SDRAM读写" class="headerlink" title="基于Avalon_MM接口的SDRAM读写"></a>基于Avalon_MM接口的SDRAM读写</h1><h2 id="1-大体思路框架"><a href="#1-大体思路框架" class="headerlink" title="1. 大体思路框架 "></a><font color= salmon size=5>1. 大体思路框架 </font ></h2><ul><li><font color= LightSkyBlue size=5>  使用Avalon_MM接口后，我们只需考虑SDRAM_Control模块（SDRAM控制模块）【内含WRfifo,RDfifo】，如何满足接收和发送数据到Avalon_MM接口即可，不用考虑SDRAM内部运行的过程。</font > </li><li><font color= red size=5> 大致有四个状态,IDLE(空闲状态),WRITE(SDRAM写过程)，READ(SDRAM读过程)，DONE（结束）</font ></li></ul><font color= fuchsia size=5> <details><summary>展开查看相关代码</summary><pre><code> <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//状态转移条件</span></span><br><span class="line"> <span class="keyword">assign</span> idle2read  = (state_c == IDLE) &amp;&amp; (rd_req) ;  <span class="comment">//当按键按下时，状态从IDLE跳转到READ</span></span><br><span class="line"> <span class="keyword">assign</span> idle2write = (state_c == IDLE) &amp;&amp; (rdusedw_sig &gt;= <span class="number">8&#x27;d3</span>);<span class="comment">//当WRfifo读端表示至少还有3个16bit数据后，状态从IDLE跳转到READ，开始进行读操作</span></span><br><span class="line"> <span class="keyword">assign</span> read2done  = (state_c == READ) &amp;&amp; (end_cnt_rd_num);<span class="comment">//当读出数据计数器记到结束条件（读出数据个数为3时），状态从READ跳转到DONE</span></span><br><span class="line"> <span class="keyword">assign</span> write2done = (state_c == WRITE)&amp;&amp; (end_cnt_wr_num);<span class="comment">//当写入数据计数器记到结束条件（写入数据个数为3时），状态从WRITE跳转到DONE</span></span><br><span class="line"> <span class="keyword">assign</span> done2idle  = (state_c == DONE) &amp;&amp; <span class="number">1&#x27;d1</span>;<span class="comment">//DONE状态直接跳转为IDLE</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p></code></pre></p></details></font > <h2 id="2-SDRAM从写入到读出的过程"><a href="#2-SDRAM从写入到读出的过程" class="headerlink" title="2.SDRAM从写入到读出的过程"></a><font color= salmon size=5>2.SDRAM从写入到读出的过程</font ></h2> <font color= LightSkyBlue size=5>    1.UART_RX接收到PC串口发送的8bit数据,传入SDRAM_Control模块里的WRfifo。  <br>2.WRfifo根据Avalon总线协议和WRfifo自身状态，控制WRfifo的读写使能的开启条件。</font >  <br><font color= fuchsia size=5> <details><summary>展开查看相关代码</summary><pre><code>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WRfifo</span></span><br><span class="line"><span class="keyword">assign</span> wrreq_sig = (din_vld) &amp;&amp; (!wrfull_sig) ;  </span><br><span class="line"><span class="comment">//WRfifo里的写使能开启条件为：从UART_RX输入到SDRAM_Control模块的8bit数据有效(din_vld)，且WR_fifo写非空的状态下(!wrfull_sig)，进行WRfifo的写操作。</span></span><br><span class="line"><span class="keyword">assign</span> rdreq_sig = (!rdempty_sig) &amp;&amp; (!avm_waitrequest) &amp;&amp; (state_c == WRITE);</span><br><span class="line"><span class="comment">//WRfifo里的读使能开启条件为：当WRfifo读非空的状态下（rdreq_sig），且上升沿对等待请求（avm_waitrequest）为低的状态下【因为只有在avm_waitrequest为低电平时数据才能传入Avalon_MM串口(当avm_waitrequest为高电平时SDRAM还没有准备好接受或者发送数据)，进而传入SDRAM】， 且在读状态下，进行WRfifo数据的数据读出。</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p></code></pre></p></details></font ><font color= LightSkyBlue size=5>    <br> 3.WRfifo的读使能要在读状态下且avm_waitrequest为低，WRfifo非读空状态下才有效。当WRfifo读使能有效时,要确保WRfifo里读端的每个16bit数据与SDRAM所要写入的地址的同时输入到Avalon_MM接口模块。所以让地址（Addr）计数开启条件和写入Avalon_MM 16bit数据个数开始计数条件都在读状态下且avm_waitrequest为低时开始，当avm_waitrequest拉高时停止计数，保持地址和数据，当avm_waitrequest再一次为低电平时，继续写入16bit数据和对应地址。因为avm_waitrequest会在接受到wr_en或rd_en信号后拉高，当SDRAM能接受数据后才会拉低avm_waitrequest，拉低时的每个时钟周期就可以接受1个16bit数据与其对应的地址位。</font >  <font color= fuchsia size=5>   <details><summary>展开查看相关代码</summary><pre><code>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cnt_wr_addr 写地址计数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">23</span>:<span class="number">0</span>] cnt_wr_addr;         <span class="comment">//24位宽地址   </span></span><br><span class="line"><span class="keyword">wire</span> add_cnt_wr_addr;                                                       </span><br><span class="line"><span class="keyword">wire</span> end_cnt_wr_addr;</span><br><span class="line"><span class="keyword">assign</span> add_cnt_wr_addr = (state_c == WRITE) &amp;&amp; (!avm_waitrequest); <span class="comment">//地址计数开始条件为读状态下，且avm_waitrequest为低电平时。保证了在WRfifo读请求有效时，同时传入地址位。当在读状态下，avm_waitrequest为低电平的每个周期都写入1个地址。（为了方便我们把地址计数数据也当为地址数据（相当于在读状态下，avm_waitrequest为低电平的每个周期都输入从0开始到对应第几次的地址））</span></span><br><span class="line"><span class="keyword">assign</span> end_cnt_wr_addr = (add_cnt_wr_addr) &amp;&amp; (cnt_wr_addr == <span class="number">24&#x27;d10</span>); <span class="comment">//最多可以计数10个地址（相当于最多写入10个地址）【可以修改为大于或等于写入的数据个数的地址位，因为每个数据需要与对应的地址匹配】</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">         cnt_wr_addr &lt;= <span class="number">24&#x27;d0</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (add_cnt_wr_addr) <span class="keyword">begin</span></span><br><span class="line">         <span class="keyword">if</span> (end_cnt_wr_addr) <span class="keyword">begin</span></span><br><span class="line">            cnt_wr_addr &lt;= <span class="number">24&#x27;d0</span>;</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">         <span class="keyword">else</span>  cnt_wr_addr &lt;= cnt_wr_addr +<span class="number">24&#x27;d1</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若地址计数个数设置为大于一次连续输入数据的个数，多余的地址可以作为串口端超过一次连续输入个数的数据的地址。</p><p>example：在PC串口助手端口一次性输入16个8bit数据，状态机从IDLE跳转到WRITE的条件为rdusedw_sig &gt;&#x3D; 8’d3<br>（相当于wrusedw_sig &gt;&#x3D; 8’d6【因为WRfifo写端为8bit数据，读端为16bit数据，写端每写入2个8bit数据，写端<br>wrusedw_sig加2，读端rdusedw_sig才加1】），写入数据次数到3的时候，状态机从WRITE跳到DONE，DONE直接跳转<br>到IDLE，因状态机从IDLE跳转到WRITE的条件为rdusedw_sig &gt;&#x3D; 8’d3，WRfifo读出了3个16bits数据，还剩5个16b<br>it数据，满足IDLE跳转到WRITE的条件，再次进入写状态，等待avm_waitrequest为低电平时，把剩余的3个地址和WR<br>fifo里后续的3个16bit数据，依次同时对应传输到Avalon_MM，这样循环，直到不满足跳转条件。</p><p>【特殊情况】&#123;当数据大于剩余地址时，存储会出错，这需要考虑&#125;</p><p></code></pre></p></details></font >    ]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
          <category> SDRAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> SDRAM </tag>
            
            <tag> Avalon_MM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA内部结构</title>
      <link href="/2023/05/22/FPGA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84/"/>
      <url>/2023/05/22/FPGA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="FPGA内部结构"><a href="#FPGA内部结构" class="headerlink" title="FPGA内部结构"></a>FPGA内部结构</h1><h2 id="1-可编程逻辑单元（LABS）"><a href="#1-可编程逻辑单元（LABS）" class="headerlink" title="1. 可编程逻辑单元（LABS）"></a><font color= salmon size=5>1. 可编程逻辑单元（LABS）</font ></h2><ul><li><font color= LightSkyBlue size=5>  FPGA的基本可编程逻辑单元是由查找表（LUT）和寄存器（Register）组成的，查找表完成纯组合逻辑功能。FPGA内部寄存器可配置为带同步&#x2F;异步复位和置位、时钟使能的触发器，也可以配置成为锁存器。FPGA一般依赖寄存器完成同步时序逻辑设计。</font > <details><summary>展开查看</summary><pre><code>-<font color= LightSlateGray size=3> 【包含逻辑单元（LEs）,自适逻辑模块（ALMs）,查找表（LUT）,进位逻辑，输出寄存器逻辑】lut dff辅助逻辑</font >  -<font color= LightSlateGray size=3> LE和ALM是同级的，有些LAB里是LE，有些是ALM。ALM比LE复杂一些。</font > </code></pre></details></li></ul><h2 id="2-可编程连线-丰富的布线资源"><a href="#2-可编程连线-丰富的布线资源" class="headerlink" title="2.可编程连线(丰富的布线资源)"></a><font color= salmon size=5>2.可编程连线(丰富的布线资源)</font ></h2><ul><li><font color= LightSkyBlue size=5>  布线资源连通FPGA内部所有单元，连线的长度和工艺决定着信号在连线上的驱动能力和传输速度。布线资源的划分：<br><br>  (1)全局性的专用布线资源：以完成器件内部的全局时钟和全局复位&#x2F;置位的布线；<br><br>  (2)长线资源：用以完成器件Bank间的一些高速信号和一些第二全局时钟信号的布线；<br><br>  (3)短线资源：用来完成基本逻辑单元间的逻辑互连与布线；<br><br>  (4)其他：在逻辑单元内部还有着各种布线资源和专用时钟、复位等控制信号线。</font ></li></ul><h2 id="3-可编程输入输出单元（I-x2F-O单元）"><a href="#3-可编程输入输出单元（I-x2F-O单元）" class="headerlink" title="3.可编程输入输出单元（I&#x2F;O单元）"></a><font color= salmon size=5>3.可编程输入输出单元（I&#x2F;O单元）</font ></h2><details><summary>展开查看</summary><pre><code>- <font color= LightSlateGray size=3>   （多个I/O标准，差分信号输出，电流驱动强度/速度调节，片上终端/上拉电阻，开漏/三态）</font > - </code></pre></details><ul><li><font color= LightSkyBlue size=5>  目前大多数FPGA的I&#x2F;O单元被设计为可编程模式，即通过软件的灵活配置，可适应不同的电器标准与I&#x2F;O物理特性；可以调整匹配阻抗特性，上下拉电阻；可以调整输出驱动电流的大小等。</font ></li></ul><h2 id="4-时钟资源"><a href="#4-时钟资源" class="headerlink" title="4.时钟资源"></a><font color= salmon size=5>4.时钟资源</font ></h2><details><summary>展开查看</summary><pre><code>- <font color= LightSlateGray size=3>   （PLL,专用输入时钟引脚，时钟控制模块，时钟布线网络）</font > - </code></pre></details><ul><li><font color= LightSkyBlue size=5>  专用输入时钟引脚、锁相环（PLL）、时钟控制模块（选择时钟以提供时钟布线网、可启用&#x2F;禁用时钟以节能）、时钟布线网络（全局时钟网络驱动整个设备、局部时钟网络驱动特定的设备区域）</font ></li></ul><h2 id="5-嵌入式块RAM"><a href="#5-嵌入式块RAM" class="headerlink" title="5.嵌入式块RAM"></a><font color= salmon size=5>5.嵌入式块RAM</font ></h2><ul><li><font color= LightSkyBlue size=5>  目前大多数FPGA都有内嵌的块RAM。嵌入式块RAM可以配置为单端口RAM、双端口RAM、伪双端口RAM、CAM、FIFO等存储结构。CAM，即为内容地址存储器。写入CAM的数据会和其内部存储的每一个数据进行比较，并返回与端口数据相同的所有内部数据的地址。简单的说，RAM是一种写地址，读数据的存储单元；CAM与RAM恰恰相反。</font ></li></ul><h2 id="6-底层嵌入功能单元"><a href="#6-底层嵌入功能单元" class="headerlink" title="6.底层嵌入功能单元"></a><font color= salmon size=5>6.底层嵌入功能单元</font ></h2><details><summary>展开查看</summary><pre><code>- <font color= LightSlateGray size=3>   （DSP模块，高速收发器，硬IP模块）</font >- </code></pre></details><ul><li><font color= LightSkyBlue size=5>  底层嵌入功能单元是指通用程度较高的嵌入式功能模块。如锁相环(Phase Locked Loop,PLL)、DLL(Delay Locked Loop)、DSP(Digital Signal Processing)和CPU等。</font ></li></ul><details><summary>展开查看</summary><pre><code><h2 id="FPGA→LAB（逻辑阵列块）→LE-ALM-（自适应逻辑模块）【最小逻辑单元】→LUT-触发器-辅助逻辑"><a href="#FPGA→LAB（逻辑阵列块）→LE-ALM-（自适应逻辑模块）【最小逻辑单元】→LUT-触发器-辅助逻辑" class="headerlink" title="FPGA→LAB（逻辑阵列块）→LE(ALM)（自适应逻辑模块）【最小逻辑单元】→LUT+触发器+辅助逻辑"></a>FPGA→LAB（逻辑阵列块）→LE(ALM)（自适应逻辑模块）【最小逻辑单元】→LUT+触发器+辅助逻辑</h2><p></code></pre></p></details>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
          <category> FPGA内部结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> FPGA内部结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/20/hello-world/"/>
      <url>/2023/05/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Icaurs</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
